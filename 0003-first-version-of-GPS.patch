From fc41c5b27af81f16486522ef4c388c20f49ca42b Mon Sep 17 00:00:00 2001
From: marui <marui@emsym.com>
Date: Fri, 14 Apr 2017 11:11:11 +0800
Subject: [PATCH 3/4] first version of GPS


diff --git a/Sources/GPS.c b/Sources/GPS.c
new file mode 100644
index 0000000..f45a659
--- /dev/null
+++ b/Sources/GPS.c
@@ -0,0 +1,227 @@
+/*
+ * GPS.c
+ *
+ *  Created on: Apr 14, 2017
+ *      Author: hflw
+ */
+
+
+#include "uart_comm.h"
+#include "util.h"
+#include "PE_Types.h"
+#include "PE_Error.h"
+#include "ATcommand.h"
+
+#include "WIFI.h"
+#include "GPRS.h"
+#include "uart0.h"
+
+//char wifi_cmd_recv_buf[1024];
+
+extern uart0_TDeviceDataPtr uart0DeviceDataPrv;
+extern char at_cmd_recv_buf[MAX_CMD_RECV_BUF_SIZE];
+extern char *g_at_result_last_valid_pointer_in_recv_buf , *g_at_result_recv_end_pointer;
+extern char at_cmd_result_checking_buf[MAX_CMD_RECV_BUF_SIZE];
+extern struct at_expected_result_and_condition g_current_at_expected_result;
+
+int g_gps_connected=0;
+
+/*uint16_t WiFiGPSStartRecv_internal()
+{
+	uint16_t result;
+	result = uart_read_async(WIFIGPS_COM_PORT, at_cmd_recv_buf, MAX_CMD_RECV_BUF_SIZE);
+	return result;
+}
+
+uint16_t WIFIATExecute(char *cmd, char *expect_result)
+{
+	return ATExecuteOnce(WIFIGPS_COM_PORT, cmd, wifi_cmd_recv_buf, MAX_WIFI_CMD_RECV_BUF_SIZE, expect_result);
+}
+
+uint16_t WIFIATExecuteComplex(char *cmd, CHECK_RESULT_FUNC_PTR checkfunc, char *expect_result, char shortmode, char * value, int * param1, int * param2)
+{
+	return ATExecuteComplex(WIFIGPS_COM_PORT, cmd, wifi_cmd_recv_buf, MAX_WIFI_CMD_RECV_BUF_SIZE, checkfunc, expect_result, shortmode, value, param1, param2);
+
+}*/
+
+
+byte GPSInit()
+{
+	int startfrom, length;
+
+	uint16_t result=ERR_OK;
+	
+	WiFiGPSStartRecv_internal();
+	log_printf("start init GPS......\n\n");
+	g_gps_connected=1;//this is HACK, we should check something
+	return result;
+	
+	/*result = WIFIATExecute( "AT\r\n", "OK\r\n");
+	if(result == ERR_OK)
+		result = WIFIATExecute( "AT+CWMODE=3\r\n", "OK\r\n");
+	log_printf("Wait WIFI to get ip......\n\n");
+	_delay_sometime(2000);
+	//if(result == ERR_OK)
+		//result = WIFIATExecute( "AT+CWJAP=\"jack_field\",\"sweethome\"\r\n", "CONNECTED\r\n");
+		//result = WIFIATExecute( "AT+CWJAP=\"NETGEAR49\",\"13029932\"\r\n", "CONNECTED\r\n");
+		//result = WIFIATExecute( "AT+CWJAP=\"dlink123\",\"yanfa999\"\r\n", "CONNECTED\r\n");
+	//WIFIATExecute( "AT+CWJAP=\"HUAWEI P9\",\"88316057\"\r\n", "CONNECTED\r\n");
+	if(result == ERR_OK)
+		result = WIFIATExecute( "AT+CIPSTART=\"TCP\",\"218.3.215.228\",3881\r\n", "CONNECT\r\n");
+	if(result != ERR_OK)//try again
+		result = WIFIATExecute( "AT+CIPSTART=\"TCP\",\"218.3.215.228\",3881\r\n", "ALREADY");
+	
+	if(result != ERR_OK)
+	{
+		log_printf("Init WIFI failed!\n");
+		g_wifi_connected = 0;
+		return result;
+	}
+	else
+	{
+		log_printf("Init WIFI success!\n");
+		g_wifi_connected = 1;
+		return ERR_OK;
+	}*/
+}
+
+#define GPS_DATA_COMING_HEADER "GPGLL,"
+uint16_t g_new_gps_data_length;
+float g_la,g_lo;
+#define MIN_GPS_DATA_COMING_DATA_LEN	13
+uint16_t	g_is_new_gps_data_received = 0;//this is indicate new gps data arrived from server
+char * g_new_gps_data_start=NULL;
+extern char recv_server_data_buf[MAX_CMD_HEX_BUF_SIZE];
+extern char *g_at_result_last_valid_pointer_in_checking_buf_tail;
+void GPSOtherCommonExpectedResultChecking()
+{
+	char *bufp;
+	char buf_len[5],*bufplentail;
+	int i;
+	int checkstrlen=strlen(at_cmd_result_checking_buf);
+	
+	//we should check other common expect result at same time
+	if((bufp= strstr(at_cmd_result_checking_buf, GPS_DATA_COMING_HEADER)) >0)
+	{
+		//bufp += strlen(GPS_DATA_COMING_HEADER) + 1;//skip space
+		if(g_at_result_last_valid_pointer_in_checking_buf_tail - at_cmd_result_checking_buf < MIN_GPS_DATA_COMING_DATA_LEN)
+			return;
+		
+		bufp += strlen(GPS_DATA_COMING_HEADER) + 1;//skip ,
+					g_new_gps_data_start = bufp;
+					/*bufplentail = bufp;
+					for(i=0;i<5;i++)
+						if(*bufplentail == ',')
+							break;
+						else
+							buf_len[i]=*bufplentail++;
+					//*bufplentail = 0;
+					buf_len[i]=0;
+					g_la = atoi(buf_len);*/
+		
+		/*if(*bufplentail == ':' && g_new_gps_data_length)
+			if(bufp+g_new_gps_data_length + 2 <= g_at_result_last_valid_pointer_in_checking_buf_tail)
+				g_new_gps_data_start = bufplentail+1;
+			else
+				return;
+		else
+			return;*/
+					
+
+		g_new_gps_data_length=0;
+		while(bufp[g_new_gps_data_length]!='\0' &&
+				bufp[g_new_gps_data_length]!='\n' &&
+				bufp[g_new_gps_data_length]!='\r' &&
+				bufp+g_new_gps_data_length < at_cmd_result_checking_buf + checkstrlen )
+			g_new_gps_data_length++;
+		
+		if( g_new_gps_data_length < MIN_GPS_DATA_COMING_DATA_LEN)
+			return;
+		if(bufp[g_new_gps_data_length] == '\r' || bufp[g_new_gps_data_length] == '\n')
+		{
+			if( g_new_gps_data_length > MAX_CMD_HEX_BUF_SIZE - 1)
+			{
+				log_printf("---too many data from server via gps!\n");
+				g_new_gps_data_length = MAX_CMD_HEX_BUF_SIZE -1;
+			}
+			//move out data from checking buf because it may be flush later
+			memcpy(recv_server_data_buf,g_new_gps_data_start, g_new_gps_data_length);
+			recv_server_data_buf[g_new_gps_data_length] = '\0';
+			//g_new_gps_data_start = recv_server_data_buf;
+			log_printf("<--- get gps data:len:%d data:%s\n", g_new_gps_data_length,g_new_gps_data_start);
+			//for(i=0;i<g_new_gps_data_length;i++)
+			//	log_printf("%0x ",recv_server_data_buf[i]);
+			//log_printf("\n");
+			
+			g_is_new_gps_data_received = 1;//set flag
+			//ATUpdateLastValidResulPointerInCheckingBuf(bufp);
+			ATUpdateLastValidResulPointerInCheckingBuf(g_new_gps_data_start + g_new_gps_data_length);
+		}
+
+		//uart2_CancelBlockTransmission(uart2DeviceDataPrv);
+	}
+	/*if((bufp= strstr(at_cmd_result_checking_buf, GPRS_CLOSE_MIPLINK_HEADER)) >0
+			|| (bufp= strstr(at_cmd_result_checking_buf, GPRS_RESET_HEADER)) >0 )
+	{
+		g_is_gprs_tcp_closed = 1;//set flag
+		ATUpdateLastValidResulPointerInCheckingBuf(bufp + strlen(GPRS_CLOSE_MIPLINK_HEADER));
+
+		//uart2_CancelBlockTransmission(uart2DeviceDataPrv);
+	}
+	if((bufp= strstr(at_cmd_result_checking_buf, MQTT_CONNECTED_HEADER)) >0)
+	{
+		//g_mqtt_alreadd_connected_when_try_conn = 1;//g_mqtt.state = MQTT_STATE_CONNECTED;//set flag
+		ATUpdateLastValidResulPointerInCheckingBuf(bufp + strlen(MQTT_CONNECTED_HEADER));
+
+		//uart2_CancelBlockTransmission(uart2DeviceDataPrv);
+	}
+	
+	if((bufp= strstr(at_cmd_result_checking_buf, GPRS_CLOSE_ERROR_HEADER)) >0)
+	{
+		g_is_gprs_error_detected = 1;//set flag
+		ATUpdateLastValidResulPointerInCheckingBuf(bufp);
+
+		//uart2_CancelBlockTransmission(uart2DeviceDataPrv);
+	}*/
+
+}
+
+void GPSCheckRecvResult_internal_async()
+{
+	char *tmpp=at_cmd_recv_buf;
+	if(!uart0DeviceDataPrv)
+		return ERR_PARAM_VALUE;
+
+	if(uart0DeviceDataPrv->InpRecvDataNum > MIN_RESULT_STRING_SIZE)
+	{
+		if(uart0DeviceDataPrv->InpRecvDataNum < MAX_CMD_RECV_BUF_SIZE)
+			tmpp = at_cmd_recv_buf + uart0DeviceDataPrv->InpRecvDataNum; 
+		else
+			tmpp = &at_cmd_recv_buf[MAX_CMD_RECV_BUF_SIZE];//NOTE: this is out of the memory
+		if(tmpp != g_at_result_recv_end_pointer)//new data came
+		{
+			g_at_result_recv_end_pointer = tmpp;
+#ifdef TIMER_DEBUG
+			log_printf("gps recv len:%d recvend:%x\n", 
+				uart0DeviceDataPrv->InpRecvDataNum, g_at_result_recv_end_pointer);
+#endif
+			//copy data from recv buffer to result checking buffer
+			if(ATCopyATRecvData2ResultCheckingBuf()== ERR_OK)//copy success
+			{
+				//check AT result from result checking buffer
+				//g_current_at_expected_result.analyze_result = ATCheckResultFromResultCheckingBuf();
+			
+				//check other common expected result from checking buffer
+				//the result will be marked in following function
+				GPSOtherCommonExpectedResultChecking();
+			
+				//update last valide result pointer
+				ATUpdateLastValidResulPointerInRecvBuf();
+			}
+		}
+	}
+
+}
+
+
+
diff --git a/Sources/GPS.h b/Sources/GPS.h
new file mode 100644
index 0000000..3131692
--- /dev/null
+++ b/Sources/GPS.h
@@ -0,0 +1,19 @@
+/*
+ * GPS.h
+ *
+ *  Created on: Apr 14, 2017
+ *      Author: hflw
+ */
+
+#ifndef GPS_H_
+#define GPS_H_
+
+#define MAX_WIFI_CMD_RECV_BUF_SIZE 1500
+#define AT_CMD_WIFI_HEAD_FAST_SEND "AT+CIPSEND"
+
+byte WIFIInit();
+uint16_t WIFISendDataFromLineBuffer(char * buf, uint16_t length);
+uint16_t WIFIStartAsyncRecv();
+
+
+#endif /* GPS_H_ */
diff --git a/Sources/mqx_tasks.c b/Sources/mqx_tasks.c
index c8b0b86..788e50e 100644
--- a/Sources/mqx_tasks.c
+++ b/Sources/mqx_tasks.c
@@ -97,6 +97,10 @@ extern char at_cmd_result_checking_buf[MAX_CMD_RECV_BUF_SIZE];
 extern char * g_buffirstbyte;
 extern char * g_buflastbyte;
 
+extern int g_gps_connected;
+extern uint16_t g_is_new_gps_data_received;
+extern uint16_t	g_new_gps_data_length;
+extern char * g_new_gps_data_start;
 //following flags identify the network status
 int g_tcp_connected=0;
 int g_mqtt_connected=0;
@@ -299,6 +303,12 @@ void TaskInit()
 		 		  
 		  //init GPRS or WiFi, we should connect WiFi first
 		  //wifi_enable_on(0);
+		  gps_pow_on(1);
+		  result = GPSInit();
+		  if(result!=ERR_OK)
+			  log_printf("Init GPS module failed!\n");
+		  else
+			  log_printf("Init GPS module success!\n");
 		  //while(1);
 		  while(1)
 		  {
@@ -438,8 +448,11 @@ void Task1_task(uint32_t task_init_data)
 		  //Check GPRS recved data and analyze them
 			  if(!g_wifi_connected)
 				  GPRSCheckRecvResult_internal();//checking result buffer
-			  else
+			  else 
 				  WIFICheckRecvResult_internal_async();//checking wifi result buffer
+			  
+			  if(g_gps_connected)
+				  GPSCheckRecvResult_internal_async();
 		  
 		  //check if tcp connection is closed
 		  if(g_is_gprs_tcp_closed)
@@ -464,7 +477,7 @@ void Task1_task(uint32_t task_init_data)
 			  mqtt_init_and_connect();
 		  }
 		  //check if we receive new data from GPRS, normally this data is come from server
-		  if( g_is_new_gprs_data_received|| g_is_new_wifi_data_received)
+		  if( g_is_new_gprs_data_received|| g_is_new_wifi_data_received ||g_is_new_gps_data_received)
 		  {
 			  GPTC_SetFieldValue(NULL, PTC0_LED9, 1);//led on
 			  //we should create a message here to trigger GPRS sending
@@ -472,8 +485,10 @@ void Task1_task(uint32_t task_init_data)
 			  {
 				  if(g_is_new_gprs_data_received)
 					  result = _send_msg_to_queue(g_gprs_msg_queue_p, NEW_GPRS_DATA, g_new_gprs_data_start, NULL, g_new_gprs_data_length);
-				  else
+				  else if(g_is_new_wifi_data_received)
 					  result = _send_msg_to_queue(g_gprs_msg_queue_p, NEW_GPRS_DATA, g_new_wifi_data_start, NULL, g_new_wifi_data_length);
+				  else
+					  result = _send_msg_to_queue(g_gprs_msg_queue_p, NEW_GPRS_DATA, g_new_gps_data_start, NULL, g_new_gps_data_length);
 				  if(result == ERR_OK)
 				  {
 					  if(g_is_new_gprs_data_received)
-- 
1.9.4.msysgit.0

